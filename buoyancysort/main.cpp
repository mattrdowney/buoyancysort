#include "stdafx.h"
#include <algorithm>
#include <functional>
#include <iostream>
#include <map>
#include <math.h>
#include <random>
#include <set>
#include <utility>
#include "bubble-sort.h"
#include "buoyancysort.h"
#include "comb-sort.h"
#include "heap-tests.h"
#include "hoare-partition.h"
#include "hybrid-hierarchysort.h"
#include "in-place-hierarchysort.h"
#include "insertion-sort.h"
#include "int-that-tracks-comparisons.h"
#include "interlaced-double-binary-heap.h"
#include "interlaced-entangled-double-binary-heap.h"
#include "max-heap.h"
#include "median-of-medians.h"
#include "min-heap.h"
#include "ordered-max-heap.h"
#include "ordered-min-heap.h"
#include "out-of-place-hierarchysort.h"
#include "print.h"
#include "quicksort.h"
#include "reverse.h"
#include "semi-stable-partition.h"
#include "shell-sort.h"
#include "sift.h"
#include "sorted.h"
#include "spindle.h"
#include "stable-partition.h"

//typedef int current_type;
typedef IntThatTracksComparisons::IntThatTracksComparisons current_type;

int main()
{
	//HeapTests::heap_tests();
	const long size = 1000000;
	const long tuple_size = 2;
	std::vector<current_type> data(size);
	for (std::size_t i = 0; i < size; i += 1)
	{
		/*if ((i % 2) == 0)
		{
			data[i] = size/2;
			continue;
		}*/
		data[i] = size - i;
	}
	
	std::random_device random_device;
	std::mt19937 random_number_generator(random_device());
	random_number_generator.seed(26);
	std::shuffle(&data[0], (&data[size-1]) + 1, random_number_generator);
	
	//Print::print((current_type*)data.data(), -1, size);
	
	//HeapTests::test_min_heap<current_type>((current_type*)data.data(), -1, size, tuple_size);
	//HeapTests::test_max_heap<current_type>((current_type*)data.data(), -1, size, tuple_size);
	//HeapTests::test_min_heap_alignment<current_type>((current_type*)data.data(), -1, size, tuple_size);
	//HeapTests::test_max_heap_alignment<current_type>((current_type*)data.data(), -1, size, tuple_size);

	//IntThatTracksComparisons::reset_comparisons();

	//Hierarchysort::in_place<current_type>((current_type*)data.data(), -1, size);
	std::vector<long> gap_sequence1 = ShellSort::extrapolated_ciura_tokuda1;
	//std::vector<long> gap_sequence2 = ShellSort::gap_sequence_generator(ShellSort::generalized_ciura4, 25);
	std::vector<long> gap_sequence2 = ShellSort::extrapolated_ciura_tokuda2;
	//std::vector<long> gap_sequence2 = ShellSort::gap_sequence_generator(ShellSort::extrapolated_ciura, 20);
	//std::vector<long> gap_sequence2 = ShellSort::extrapolated_ciura_tokuda3;
	//ShellSort::empirical_comparison_range(gap_sequence1, gap_sequence2, 45000, 120000, 40991, 41200, 41);
	//ShellSort::empirical_comparison(gap_sequence1, gap_sequence2, 45000, 120000, 200);
	ShellSort::empirical_comparison_inner_range(gap_sequence1, gap_sequence2, 45000, 120000, 15870, 15871, 15874, 200);

	// 1, 4, 10, 23, 57, 142, 361, 925, 2383, 6153, 15870, 41042, 415954008 : 416282799 (328791) // ShellSort::empirical_comparison(gap_sequence1, gap_sequence2, 45000, 120000, 200);
	// 1, 4, 10, 23, 57, 142, 361, 925, 2383, 6154, 15870, 41042, 414381145 : 414440717 (59572)
	// 1, 4, 10, 23, 57, 142, 361, 925, 2383, 6155, 15870, 41042, 417805768 : 417951426 (145658)
	// 1, 4, 10, 23, 57, 142, 361, 925, 2383, 6156, 15870, 41042, 427245404 : 427607297 (361893)
	// 1, 4, 10, 23, 57, 142, 361, 925, 2383, 6157, 15870, 41042, 415936203 : 416298906 (362703)
	// 1, 4, 10, 23, 57, 142, 361, 925, 2383, 6158, 15870, 41042, 410861627 : 410988531 (126904)
	// 1, 4, 10, 23, 57, 142, 361, 925, 2383, 6159, 15870, 41042, 393457569 : 394597128 (1139559)
	// 1, 4, 10, 23, 57, 142, 361, 925, 2383, 6160, 15870, 41042, 423254679 : 424027116 (772437)
	// 1, 4, 10, 23, 57, 142, 361, 925, 2383, 6161, 15870, 41042, 425842771 : 426805399 (962628)
	// 1, 4, 10, 23, 57, 142, 361, 925, 2383, 6162, 15870, 41042, 408324476 : 410261252 (1936776)
	// 1, 4, 10, 23, 57, 142, 361, 925, 2383, 6163, 15870, 41042, 426266441 : 428937044 (2670603)

	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15860, 41042, 6649880:6671613 (21733) //ShellSort::empirical_comparison_inner_range(gap_sequence1, gap_sequence2, 45000, 120000, 15870, 15860, 15900, 3);
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15861, 41042, 4606570:4622953 (16383)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15862, 41042, 7490335 : 7483298 (-7037)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15863, 41042, 8405416 : 8418186 (12770)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15864, 41042, 5108209 : 5118800 (10591)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15865, 41042, 5127325 : 5120087 (-7238)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15866, 41042, 5961359 : 5993858 (32499)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15867, 41042, 6021064 : 6021267 (203)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15868, 41042, 7558036 : 7552749 (-5287)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15869, 41042, 5946040 : 5957388 (11348)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15870, 41042, 7350149 : 7350149 (0)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15871, 41042, 4906095 : 4918092 (11997)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15872, 41042, 7096847 : 7121727 (24880)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15873, 41042, 5384298 : 5397730 (13432)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15874, 41042, 5111653 : 5119947 (8294)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15875, 41042, 5633772 : 5622892 (-10880)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15876, 41042, 5607940 : 5608671 (731)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15877, 41042, 4954671 : 4944722 (-9949)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15878, 41042, 6088861 : 6126895 (38034)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15879, 41042, 6775512 : 6767945 (-7567)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15880, 41042, 5476165 : 5482138 (5973)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15881, 41042, 7100282 : 7100543 (261)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15882, 41042, 8337816 : 8341537 (3721)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15883, 41042, 8499361 : 8508769 (9408)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15884, 41042, 8779412 : 8767925 (-11487)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15885, 41042, 4636280 : 4659657 (23377)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15886, 41042, 6549563 : 6557008 (7445)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15887, 41042, 5943682 : 5948078 (4396)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15888, 41042, 6859795 : 6854797 (-4998)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15889, 41042, 7588833 : 7587795 (-1038)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15890, 41042, 5415941 : 5450749 (34808)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15891, 41042, 6655554 : 6656382 (828) // A good example of the dangers of undersampling (and oversampling on high-risk / high-reward segments)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15892, 41042, 7430408 : 7442401 (11993)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15893, 41042, 8470710 : 8483368 (12658)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15894, 41042, 7814245 : 7821737 (7492)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15895, 41042, 3944060 : 3960218 (16158)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15896, 41042, 5419218 : 5428167 (8949)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15897, 41042, 6661718 : 6666372 (4654)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15898, 41042, 5110942 : 5117347 (6405)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15899, 41042, 5964793 : 5990688 (25895)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15900, 41042, 7536982 : 7529904 (-7078)


	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15871, 41042, 417544580 : 419491558 (1946978)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15872, 41042, 413007588 : 413105431 (97843)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15873, 41042, 405373041 : 405639293 (266252)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15874, 41042, 416445113 : 416684124 (239011)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15875, 41042, 415904611 : 415989596 (84985) // ShellSort::empirical_comparison_inner_range(gap_sequence1, gap_sequence2, 45000, 120000, 15870, 15875, 15884, 200);
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15876, 41042, 399439895 : 399667461 (227566)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15877, 41042, 408859890 : 408852578 (-7312)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15878, 41042, 405381992 : 407269292 (1887300)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15879, 41042, 421753303 : 421879124 (125821)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15880, 41042, 412074742 : 412099031 (24289)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15881, 41042, 421487512 : 421744485 (256973)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15882, 41042, 416762549 : 416715886 (-46663)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15883, 41042, 412186520 : 412383950 (197430)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15884, 41042, 416857356 : 417028746 (171390)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15885, 41042, 422005084:423119990 (1114906)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15886, 41042, 410701571:411270461 (568890)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15887, 41042, 407440958 : 407618583 (177625)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15888, 41042, 429026222 : 429463805 (437583)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15889, 41042, 406560475 : 406559795 (-680)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15890, 41042, 409546620 : 410050283 (503663)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15891, 41042, 412398625 : 412325540 (-73085)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15892, 41042, 411117367 : 411644232 (526865)
	//1, 4, 10, 23, 57, 142, 361, 925, 2383, 6150, 15893, 41042, 431088162 : 431169504 (81342)

	//long long comparisons = IntThatTracksComparisons::get_comparisons();

	//Sorted::verify((current_type*)data.data(), -1, size);
	//Print::print((current_type*)data.data(), -1, size);

	//HeapTests::test_min_heap<current_type>((current_type*)data.data(), -1, size, tuple_size);
	//HeapTests::test_max_heap<current_type>((current_type*)data.data(), -1, size, tuple_size);
	//HeapTests::test_min_heap_alignment<current_type>((current_type*)data.data(), -1, size, tuple_size);
	//HeapTests::test_max_heap_alignment<current_type>((current_type*)data.data(), -1, size, tuple_size);
	
	//std::cout << comparisons << std::endl;
	//float cost_per_element = ((float)comparisons) / size;
	//std::cout << cost_per_element << std::endl;

	char word;
	std::cin >> word;
	return 0;
}